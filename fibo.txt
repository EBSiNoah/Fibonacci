How to find out Unused memory's size in Recursive fibonacci method?

What about do subtraction from overall size?
As an inductive result, the size of a natural number 'N' its Fibo binary tree's size is same with depth (N-2) full binary tree.
Which means it size as formula, from k=0 to N-2 Sigma 2^k.
It can express like Size=2*(2^N-1)/(2-1)-2^(n-1)-2^N.
The result is Size-(N+1)
---------------------------------------11.27.--------------------------------------
비선형적인 방법으로 피보나치 숫자를 구하는 방법이다.
1 1
1 0
인 2*2 행렬이 있는데, (0,0) 원소가 해당 행렬을 제곱했을시 제곱N번의 N+1번째 피보나치 숫자가 된다.
행렬의 성질에 따라 재귀적인 방법으로 구하는 방법과 다르게 몇몇 중간 값은 알 필요가 없다.
우선 첫번째로 행렬곱을 만들 필요가 있겠다고 생각했다.
이 문제에서는 2*2행렬에 대해서 다루기 때문에 단순히 4개의 원소에 대해서만 다루면 되지만
그보다는 일반적인 N*M 행렬과 M*K 행렬간의 곱을 구현해보고 싶었다.
그렇게 했을시에 문제가 반복을 어떤 조건에서 해야하는지 감이 잘 오지 않았다.
그래서 일반식은 일단 뒤로 미뤄두고, 2*2행렬에 한정하기로 했다.
코드 00 과 01 에서 calMat 의 차이가 이것이다. 입력된 두 행렬의 크기가 가변적인가 아니면 고정되어 있는가 인데,
가변적인 경우에 행렬곱은 아직 고려해야할 부분이 많다.

그렇게 행렬 곱에 대한 문제는 일단락 시키고, 문제의 본질로 돌아와서
예전에 있었던 1로 만들기 문제와 비슷한 성격을 가졌다는 것을 알게 되었다.
2로 나누기 혹은 -1하기 두가지 선택지인데, 구하고 싶은 피보나치 N번째 숫자에서
N을 매번 나누기 이전에 2로 나눈 나머지를 저장하고, 2로 나눈 몫을 저장하면서 restore 에 우리가 알아야 하는 행렬 제곱 N값을 원소에 넣을수 있었다.

또다른 문제는 여기서 발생했는데, 필요한 N제곱 행렬은 알지만 막상 그 행렬을 알 방법을 찾아야 한다는 것이다.
처음에 생각한것은 입력받은 전체 N의 크기를 가지는 정수형 배열을 가지고 저장할 방법을 찾고 있었는데,
생각을 좀더 확장해서 N의 크기를 가지고 2*2행렬을 원소로 가지는 배열을 선언하고, 원하는 제곱행렬의 위치는 해당 제곱값이 순서가 되도록 만들면 되는 것이었다.
이제 해야할 일은 계산한 행렬을 저장하고 원하는 시점에 불러오는 방법을 만들면 된다.
------------------------------------------11.27.----------------------------------------
fn 이라는 2*2행렬을 원소로 가지는 배열이 있다.
calMat 는 행렬 곱을 계산하는 것이다.
행렬의 성질중에 f(n)+f(m)=f(n+m) 이 있던 기억이 있다.
이를 이용해 restore 의 원소를 fn 배열의 index 값으로 하고, calMat 에 해당 index의 값을 넣어 계산된 행렬을 저장하고, 원하는 시점에 불러올수 있도록 하였다.
이 과정 중에 restore의 원소가 홀수인지, 짝수인지에 따라 올바른 계산을 하기 위해 fn[0] 에 unit 행렬을 넣어
홀수는 2로 나눈 나머지가 1이므로 fn[1] 을 추가로 곱셈하고
짝수는 2로 나눈 나머지가 0이므로 fn[0] 를 곱셈하도록 하였다.

더 나아가서, restore 의 원소중에서도 이미 알고 있는 값을 다시 곱셈할 필요가 없다는 것을 알았다.
restore의 원소는 2로 거듭하여 나눗셈을 하는 것이고, f[k]=f[k//2]+f[k//2]+f[k % 2] 가 성립한다.
restore의 원소가 모두 홀수였던 경우 소모 시간을 최대 절반으로 줄일수 있는 것이다.
